/**
* Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH. and Contributors.
* SPDX-License-Identifier:	BSL-1.0
*/
#pragma once

#include <Poco/Net/Net.h>
#include <Poco/Net/Socket.h>

#include <NIO/Notification.h>
#include <NIO/SocketReactor.h>

using Poco::Net::Socket;

namespace RK
{

class SocketReactor;

/// The base class for all notifications generated by
/// the SocketReactor.
class SocketNotification : public Notification
{
public:
    explicit SocketNotification(SocketReactor * reactor_) : reactor(reactor_) { }
    virtual ~SocketNotification() override = default;

    [[maybe_unused]] SocketReactorPtr getSocketReactor() const;
    [[maybe_unused]] Socket getSocket() const;

private:
    [[maybe_unused]] void setSocket(const Socket & socket_);

    SocketReactorPtr reactor;
    Socket socket; /// TODO delete
};

/// This notification is sent if a socket has become readable.
class ReadableNotification : public SocketNotification
{
public:
    explicit ReadableNotification(SocketReactor * reactor_) : SocketNotification(reactor_) { }
    ~ReadableNotification() override = default;

    std::string name() const override { return "read"; }
};

/// This notification is sent if a socket has become writable.
class WritableNotification : public SocketNotification
{
public:
    explicit WritableNotification(SocketReactor * reactor_) : SocketNotification(reactor_) { }
    ~WritableNotification() override = default;

    std::string name() const override { return "write"; }
};

/// This notification is sent if a socket has signalled an error.
class ErrorNotification : public SocketNotification
{
public:
    explicit ErrorNotification(SocketReactor * reactor_) : SocketNotification(reactor_) { }
    ~ErrorNotification() override = default;

    std::string name() const override { return "error"; }
    int getErrorNo() const { return error_no; }
    void setErrorNo(int error_no_) { error_no = error_no_; }

private:
    int error_no;
};

/// This notification is sent if no other event has occurred
/// for a specified time.
class TimeoutNotification : public SocketNotification
{
public:
    explicit TimeoutNotification(SocketReactor * reactor_) : SocketNotification(reactor_) { }
    ~TimeoutNotification() override = default;

    std::string name() const override { return "timeout"; }
};

/// This notification is sent when the SocketReactor does
/// not have any sockets to react to.
class IdleNotification : public SocketNotification
{
public:
    explicit IdleNotification(SocketReactor * reactor_) : SocketNotification(reactor_) { }
    ~IdleNotification() override = default;

    std::string name() const override { return "idle"; }
};

/// This notification is sent when the SocketReactor is
/// about to shut down.
class ShutdownNotification : public SocketNotification
{
public:
    explicit ShutdownNotification(SocketReactor * reactor_) : SocketNotification(reactor_) { }
    ~ShutdownNotification() override = default;

    std::string name() const override { return "shutdown"; }
};

using SocketNotificationPtr [[maybe_unused]] = std::shared_ptr<SocketNotification>;
using ReadableNotificationPtr [[maybe_unused]] = std::shared_ptr<ReadableNotification>;
using WritableNotificationPtr [[maybe_unused]] = std::shared_ptr<WritableNotification>;
using ErrorNotificationPtr [[maybe_unused]] = std::shared_ptr<ErrorNotification>;
using TimeoutNotificationPtr [[maybe_unused]] = std::shared_ptr<TimeoutNotification>;
using IdleNotificationPtr [[maybe_unused]] = std::shared_ptr<IdleNotification>;
using ShutdownNotificationPtr [[maybe_unused]] = std::shared_ptr<ShutdownNotification>;

[[maybe_unused]] [[maybe_unused]] inline SocketReactorPtr SocketNotification::getSocketReactor() const
{
    return reactor;
}


[[maybe_unused]] inline Socket SocketNotification::getSocket() const
{
    return socket;
}

[[maybe_unused]] inline void SocketNotification::setSocket(const Socket & socket_)
{
    socket = socket_;
}


}
